let lambda_tag_info_to_string (e : Lambda.tag_info) =
  match e with
  | Lambda.Blk_constructor _ -> "Blk_constructor"
  | Lambda.Blk_record_inlined _ -> "Blk_record_inlined"
  | Lambda.Blk_tuple -> "Blk_tuple"
  | Lambda.Blk_poly_var _ -> "Blk_poly_var"
  | Lambda.Blk_record _ -> "Blk_record"
  | Lambda.Blk_module _ -> "Blk_module"
  | Lambda.Blk_module_export _ -> "Blk_module_export"
  | Lambda.Blk_extension -> "Blk_extension"
  | Lambda.Blk_some -> "Blk_some"
  | Lambda.Blk_some_not_nested -> "Blk_some_not_nested"
  | Lambda.Blk_record_ext _ -> "Blk_record_ext"
  | Lambda.Blk_lazy_general -> "Blk_lazy_general"

let j_exp_to_string (e : J.expression) =
  match e.J.expression_desc with
  | J.Object _ -> "Object"
  | J.Str _ -> "String"
  | J.Var (J.Qualified (_, Some o)) -> "Var_" ^ o
  | J.Var _ -> "Var"
  | J.Call _ -> "Call"
  | J.Fun _ -> "Fun"
  | J.Array _ -> "Array"
  | J.Bin _ -> "Bin"
  | J.Cond _ -> "Cond"
  | J.New _ -> "New"
  | J.Seq _ -> "Seq"
  | J.Number _ -> "Number"
  | J.Bool _ -> "Bool"
  | J.Null -> "Null"
  | J.Undefined _ -> "Undefined"
  | J.Is_null_or_undefined _ -> "Is_null_or_undefined"
  | J.Js_not _ -> "Js_not"
  | J.Typeof _ -> "Typeof"
  | J.String_index _ -> "String_index"
  | J.Array_index _ -> "Array_index"
  | J.Static_index _ -> "Static_index"
  | J.Length _ -> "Length"
  | J.Caml_block (_, _, _, tag) ->
    Format.sprintf "Caml_block (%s)" (lambda_tag_info_to_string tag)
  | J.Caml_block_tag _ -> "Caml_block_tag"
  | J.Tagged_template _ -> "Tagged_template"
  | J.Optional_block _ -> "Optional_block"
  | J.Spread _ -> "Spread"
  | J.Await _ -> "Await"
  | J.Raw_js_code _ -> "Raw_js_code"
  | _ -> "Other"
